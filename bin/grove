#!/usr/bin/env python3
"""
grove - Git Worktree Manager

Manage named git worktrees for a mono-repo workflow.
"""

import argparse
import fcntl
import json
import os
import re
import subprocess
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed
import tempfile
from datetime import datetime
from pathlib import Path


# ── Paths ────────────────────────────────────────────────────────────────────

_OLD_CONFIG_DIR = Path.home() / ".config" / "project"
CONFIG_DIR = Path.home() / ".config" / "grove"
CONFIG_FILE = CONFIG_DIR / "config.json"
REGISTRY_FILE = CONFIG_DIR / "registry.json"

def _migrate_config_dir():
    """One-time migration from ~/.config/project to ~/.config/grove."""
    if _OLD_CONFIG_DIR.exists() and not CONFIG_DIR.exists():
        _OLD_CONFIG_DIR.rename(CONFIG_DIR)


_migrate_config_dir()

DEFAULT_CONFIG = {
    "main_repo": "/c/work/desktop_master",
    "work_dir": "/c/work",
    "dir_prefix": "dt-",
    "upstream_remote": "if",
    "fork_remote": "my",
    "default_base": "master",
    "launch": {
        "terminal": "wezterm",
        "shell_command": "fish -l -c 'claude --dangerously-skip-permissions --continue; exec fish'",
    },
}


# ── Colors ───────────────────────────────────────────────────────────────────

def _supports_color():
    return hasattr(sys.stdout, "isatty") and sys.stdout.isatty()


def _c(code, text):
    if _supports_color():
        return f"\033[{code}m{text}\033[0m"
    return str(text)


def red(t):    return _c("31", t)
def green(t):  return _c("32", t)
def yellow(t): return _c("33", t)
def blue(t):   return _c("34", t)
def cyan(t):   return _c("36", t)
def gray(t):   return _c("90", t)
def bold(t):   return _c("1", t)


# ── Config ───────────────────────────────────────────────────────────────────

class Config:
    def __init__(self):
        self._data = {}
        self._load()

    def _load(self):
        if CONFIG_FILE.exists():
            try:
                self._data = json.loads(CONFIG_FILE.read_text())
            except json.JSONDecodeError:
                die(f"Corrupt config: {CONFIG_FILE}")
        else:
            self._data = dict(DEFAULT_CONFIG)

    def save(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        _atomic_write(CONFIG_FILE, self._data)

    def __getattr__(self, name):
        if name.startswith("_"):
            return super().__getattribute__(name)
        try:
            return self._data[name]
        except KeyError:
            raise AttributeError(f"Config has no key '{name}'")

    @property
    def data(self):
        return dict(self._data)


# ── Registry ─────────────────────────────────────────────────────────────────

class Registry:
    def __init__(self):
        self._data = {"projects": {}}
        self._load()

    def _load(self):
        if REGISTRY_FILE.exists():
            try:
                self._data = json.loads(REGISTRY_FILE.read_text())
            except json.JSONDecodeError:
                die(f"Corrupt registry: {REGISTRY_FILE}")

    def save(self):
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        _atomic_write(REGISTRY_FILE, self._data)

    @property
    def projects(self):
        return self._data.get("projects", {})

    def add(self, tag, path, branch, base, issue=None):
        self._data.setdefault("projects", {})[tag] = {
            "path": str(path),
            "branch": branch,
            "base": base,
            "created": datetime.now().isoformat(timespec="seconds"),
            "issue": issue,
        }
        self.save()

    def remove(self, tag):
        self._data.get("projects", {}).pop(tag, None)
        self.save()

    def get(self, tag):
        return self._data.get("projects", {}).get(tag)

    def tags(self):
        return list(self._data.get("projects", {}).keys())

    def set_frozen(self, tag, frozen):
        p = self.get(tag)
        if not p:
            return False
        p["frozen"] = frozen
        self.save()
        return True

    def is_frozen(self, tag):
        p = self.get(tag)
        return bool(p and p.get("frozen"))


# ── Git helpers ──────────────────────────────────────────────────────────────

class Git:
    def __init__(self, repo):
        self.repo = str(repo)

    def run(self, *args, check=True, capture=True):
        cmd = ["git", "-C", self.repo] + list(args)
        try:
            r = subprocess.run(cmd, capture_output=capture, text=True, check=check, cwd=self.repo)
            if not check and r.returncode != 0:
                return None
            return r.stdout.strip() if capture else None
        except subprocess.CalledProcessError as e:
            if check:
                stderr = e.stderr.strip() if e.stderr else ""
                die(f"git {' '.join(args)} failed:\n  {stderr}")
            return None

    def run_ok(self, *args):
        """Run and return True if exit code 0."""
        cmd = ["git", "-C", self.repo] + list(args)
        r = subprocess.run(cmd, capture_output=True, text=True, cwd=self.repo)
        return r.returncode == 0

    def fetch(self, remote):
        info(f"Fetching {remote}...")
        self.run("fetch", remote, capture=False)

    def worktree_add(self, path, branch, base):
        self.run("worktree", "add", "-b", branch, str(path), base, capture=False)

    def worktree_remove(self, path, force=False, check=True):
        args = ["worktree", "remove", str(path)]
        if force:
            args.append("--force")
        return self.run(*args, capture=True, check=check)

    def worktree_move(self, old_path, new_path, check=True):
        return self.run("worktree", "move", str(old_path), str(new_path), capture=True, check=check)

    def worktree_list(self):
        """Parse `git worktree list --porcelain` into dicts."""
        raw = self.run("worktree", "list", "--porcelain")
        worktrees = []
        current = {}
        for line in raw.splitlines():
            if line.startswith("worktree "):
                if current:
                    worktrees.append(current)
                current = {"path": line[len("worktree "):]}
            elif line.startswith("HEAD "):
                current["head"] = line[len("HEAD "):]
            elif line.startswith("branch "):
                ref = line[len("branch "):]
                current["branch"] = ref.removeprefix("refs/heads/")
            elif line == "detached":
                current["detached"] = True
            elif line == "bare":
                current["bare"] = True
        if current:
            worktrees.append(current)
        return worktrees

    def branch_delete(self, branch):
        self.run("branch", "-D", branch, check=False)

    def push_delete(self, remote, branch):
        return self.run_ok("push", remote, "--delete", branch)

    def is_dirty(self, path):
        """Check if worktree at path has uncommitted changes."""
        cmd = ["git", "-C", str(path), "status", "--porcelain"]
        r = subprocess.run(cmd, capture_output=True, text=True)
        return bool(r.stdout.strip())

    def untracked_files(self, path):
        """Return list of untracked files in worktree."""
        cmd = ["git", "-C", str(path), "ls-files", "--others", "--exclude-standard"]
        r = subprocess.run(cmd, capture_output=True, text=True)
        return [f for f in r.stdout.strip().splitlines() if f]

    def uncommitted_changes(self, path):
        """Return list of files with staged or unstaged changes."""
        cmd = ["git", "-C", str(path), "diff", "--name-only", "HEAD"]
        r = subprocess.run(cmd, capture_output=True, text=True)
        files = [f for f in r.stdout.strip().splitlines() if f]
        # Also include staged changes
        cmd2 = ["git", "-C", str(path), "diff", "--cached", "--name-only"]
        r2 = subprocess.run(cmd2, capture_output=True, text=True)
        files += [f for f in r2.stdout.strip().splitlines() if f and f not in files]
        return files

    def is_pushed(self, path, branch, remote):
        """Check if local branch is pushed to remote."""
        local = self._rev_parse(path, branch)
        remote_ref = self._rev_parse(path, f"{remote}/{branch}")
        if not remote_ref:
            return False
        if not local:
            return False
        # Check that remote contains local HEAD
        cmd = ["git", "-C", str(path), "merge-base", "--is-ancestor", local, remote_ref]
        r = subprocess.run(cmd, capture_output=True, text=True)
        return r.returncode == 0

    def unpushed_commits(self, path, branch, remote):
        """Return count of commits in branch not in remote."""
        ref = f"{remote}/{branch}"
        cmd = ["git", "-C", str(path), "rev-list", "--count", f"{ref}..{branch}"]
        r = subprocess.run(cmd, capture_output=True, text=True)
        if r.returncode != 0:
            return -1  # remote branch doesn't exist
        return int(r.stdout.strip())

    def _rev_parse(self, path, ref):
        cmd = ["git", "-C", str(path), "rev-parse", "--verify", "--quiet", ref]
        r = subprocess.run(cmd, capture_output=True, text=True)
        return r.stdout.strip() if r.returncode == 0 else None

    def ahead_behind(self, path, branch, upstream_remote):
        """Return (ahead, behind) counts relative to upstream."""
        # Try multiple upstream refs
        for ref in [f"{upstream_remote}/{branch}", f"{upstream_remote}/master"]:
            cmd = ["git", "-C", str(path), "rev-list", "--left-right", "--count",
                   f"{branch}...{ref}"]
            r = subprocess.run(cmd, capture_output=True, text=True)
            if r.returncode == 0:
                parts = r.stdout.strip().split()
                if len(parts) == 2:
                    return int(parts[0]), int(parts[1])
        return 0, 0


# ── Utilities ────────────────────────────────────────────────────────────────

def die(msg):
    print(f"{red('error:')} {msg}", file=sys.stderr)
    sys.exit(1)


def warn(msg):
    print(f"{yellow('warning:')} {msg}", file=sys.stderr)


def info(msg):
    print(f"{gray(msg)}", file=sys.stderr)


def _atomic_write(path, data):
    """Write JSON atomically with backup."""
    path = Path(path)
    # Backup existing
    if path.exists():
        bak = path.with_suffix(path.suffix + ".bak")
        try:
            bak.write_text(path.read_text())
        except OSError:
            pass
    # Write to temp then rename
    fd, tmp = tempfile.mkstemp(dir=path.parent, suffix=".tmp")
    try:
        with os.fdopen(fd, "w") as f:
            fcntl.flock(f, fcntl.LOCK_EX)
            json.dump(data, f, indent=2)
            f.write("\n")
            fcntl.flock(f, fcntl.LOCK_UN)
        os.replace(tmp, path)
    except Exception:
        os.unlink(tmp)
        raise


def validate_tag(tag):
    if not tag or len(tag) > 40:
        die(f"Tag must be 1-40 characters, got {len(tag) if tag else 0}")
    if not re.match(r'^[a-zA-Z0-9][a-zA-Z0-9._-]*$', tag):
        die(f"Invalid tag '{tag}': use alphanumeric, hyphens, dots, underscores")
    return tag


def _normalize_wsl_path(path):
    """Normalize a path to lowercase WSL format: /c/work/foo"""
    s = str(path).rstrip("/\\")
    # Handle file:// URLs (e.g., file:///C:/path, file://hostname/C:/path)
    s = re.sub(r'^file://[^/]*/', '/', s)
    # Handle UNC-style admin shares: /C$/path or C$/path (after file:// stripped)
    s = re.sub(r'^/?([a-zA-Z])\$[/\\]?', lambda m: '/' + m.group(1).lower() + '/', s)
    # Handle UNC paths like //hostname/c$/path or \\hostname\c$\path
    s = re.sub(r'^[/\\]{2}[^/\\]+[/\\]([a-zA-Z])\$[/\\]?', lambda m: '/' + m.group(1).lower() + '/', s)
    # Handle Windows drive letters: C:\path, C:/path, /C:/path -> /c/path
    s = re.sub(r'^/?([a-zA-Z]):[/\\]?', lambda m: '/' + m.group(1).lower() + '/', s)
    # Normalize slashes and lowercase
    s = s.replace("\\", "/").lower()
    # Remove trailing slash and double slashes
    s = re.sub(r'/+', '/', s)
    return s.rstrip("/")


def _get_wezterm_panes():
    """Return parsed wezterm pane list, or empty list on failure."""
    try:
        r = subprocess.run(
            ["wezterm.exe", "cli", "list", "--format", "json"],
            capture_output=True, text=True, timeout=5,
        )
        if r.returncode == 0:
            return json.loads(r.stdout)
    except (subprocess.TimeoutExpired, OSError, ValueError):
        pass
    return []


def find_directory_locks(path):
    """Find processes locking a directory on Windows/WSL.
    Checks wezterm tabs and WSL processes with CWD inside the path.
    Returns list of (type, id, description) tuples.
    type is 'pane' for wezterm panes, 'pid' for WSL processes."""
    path_str = _normalize_wsl_path(Path(path).resolve())
    locks = []

    # Check wezterm tabs
    debug = os.environ.get("GROVE_DEBUG")
    for pane in _get_wezterm_panes():
        raw_cwd = pane.get("cwd", "")
        cwd = _normalize_wsl_path(raw_cwd)
        if debug:
            print(f"  [debug] tab {pane.get('tab_id')}: {raw_cwd!r} -> {cwd!r}", file=sys.stderr)
        if cwd == path_str or cwd.startswith(path_str + "/"):
            title = pane.get("title", "unknown")
            pane_id = pane.get("pane_id", "?")
            tab_id = pane.get("tab_id", "?")
            locks.append(("pane", str(pane_id), f"wezterm tab {tab_id}: {title}"))
    if debug:
        print(f"  [debug] looking for: {path_str!r}", file=sys.stderr)

    # Check WSL processes with CWD inside the path
    for entry in Path("/proc").iterdir():
        if not entry.name.isdigit():
            continue
        try:
            cwd = (entry / "cwd").resolve()
            cwd_str = _normalize_wsl_path(cwd)
            if cwd_str == path_str or cwd_str.startswith(path_str + "/"):
                cmdline = (entry / "cmdline").read_bytes().decode("utf-8", errors="replace")
                cmd = cmdline.replace("\0", " ").strip()[:80]
                if cmd:
                    locks.append(("pid", entry.name, f"pid {entry.name}: {cmd}"))
        except (OSError, ValueError):
            continue

    return locks


def _is_current_pane(pane_id):
    """Check if a wezterm pane ID is the pane running this script."""
    wez_pane = os.environ.get("WEZTERM_PANE")
    return wez_pane is not None and str(pane_id) == wez_pane


def close_wezterm_panes(locks):
    """Close wezterm panes from a locks list, skipping the current pane.
    Returns (closed_count, skipped_self)."""
    closed = 0
    skipped_self = False
    for lock_type, lock_id, desc in locks:
        if lock_type != "pane":
            continue
        if _is_current_pane(lock_id):
            skipped_self = True
            continue
        try:
            subprocess.run(
                ["wezterm.exe", "cli", "kill-pane", "--pane-id", lock_id],
                capture_output=True, text=True, timeout=5,
            )
            info(f"Closed {desc}")
            closed += 1
        except (subprocess.TimeoutExpired, OSError):
            pass
    return closed, skipped_self


def report_directory_locks(path):
    """Print which processes are locking a directory."""
    locks = find_directory_locks(path)
    if locks:
        print(f"\n{yellow('Directory is locked by:')}", file=sys.stderr)
        for _type, _id, desc in locks:
            print(f"  {desc}", file=sys.stderr)
        print(f"\n  Close these, then retry.", file=sys.stderr)
    else:
        # Locks held by Windows-side processes (wsl.exe, wslhost.exe) that
        # WSL can't introspect.  This happens when a terminal tab was opened
        # in the directory even if no WSL process still has its CWD there.
        win_path = str(path).replace("/c/", "C:\\").replace("/", "\\")
        print(f"\n{yellow('Directory is locked by a Windows process.')}", file=sys.stderr)

        # Show wezterm tabs that might be candidates
        try:
            r = subprocess.run(
                ["wezterm.exe", "cli", "list", "--format", "json"],
                capture_output=True, text=True, timeout=5,
            )
            if r.returncode == 0:
                import json
                tabs = json.loads(r.stdout)
                work_tabs = []
                for pane in tabs:
                    raw_cwd = pane.get("cwd", "")
                    if "/work/" in raw_cwd.lower() or "\\work\\" in raw_cwd.lower():
                        work_tabs.append((pane.get("tab_id", "?"), pane.get("title", "?"), raw_cwd))
                if work_tabs:
                    print(f"\n  Open wezterm tabs in /work/:", file=sys.stderr)
                    for tab_id, title, cwd in work_tabs[:5]:
                        print(f"    tab {tab_id}: {title}", file=sys.stderr)
                    if len(work_tabs) > 5:
                        print(f"    ... and {len(work_tabs) - 5} more", file=sys.stderr)
        except (subprocess.TimeoutExpired, OSError, ValueError):
            pass

        print(f"\n  Close any terminals opened in {path}", file=sys.stderr)
        print(f"  Or run from admin PowerShell: handle.exe \"{win_path}\"", file=sys.stderr)
        print(f"  Debug: GROVE_DEBUG=1 project rename ...", file=sys.stderr)


def extract_issue_from_branch(branch):
    """Extract Jira issue number from branch name patterns."""
    # Match: DESKTOP-12345, issue/DESKTOP-12345, issue/12345
    patterns = [
        r'DESKTOP-(\d+)',
        r'issue/(\d+)',
    ]
    for pat in patterns:
        m = re.search(pat, branch)
        if m:
            return int(m.group(1))
    return None


def _claude_path_encode(path):
    """Encode a filesystem path to Claude Code's project folder name."""
    return "-" + re.sub(r'[/\\._]', '-', str(path).strip("/"))


def migrate_claude_sessions(old_path, new_path):
    """Move Claude Code session data when a worktree path changes."""
    claude_dir = Path.home() / ".claude"
    projects_dir = claude_dir / "projects"
    if not projects_dir.exists():
        return

    old_folder = _claude_path_encode(old_path)
    new_folder = _claude_path_encode(new_path)
    old_dir = projects_dir / old_folder
    new_dir = projects_dir / new_folder

    if not old_dir.exists():
        return

    if new_dir.exists():
        warn(f"Claude sessions folder already exists: {new_dir}")
        return

    # Rename project folder
    old_dir.rename(new_dir)
    info(f"Moved Claude sessions: {old_folder} -> {new_folder}")

    # Update paths inside session files and index
    old_str = str(old_path)
    new_str = str(new_path)

    def _rewrite_file(filepath):
        """Replace old_str with new_str in a text file."""
        try:
            text = filepath.read_text()
            if old_str in text or old_folder in text:
                text = text.replace(old_str, new_str).replace(old_folder, new_folder)
                filepath.write_text(text)
        except Exception:
            pass

    # Update JSONL session files (cwd, paths in tool results)
    for jsonl in new_dir.glob("*.jsonl"):
        _rewrite_file(jsonl)

    # Update sessions-index.json (projectPath, fullPath)
    index = new_dir / "sessions-index.json"
    _rewrite_file(index)

    # Update history.jsonl
    history = claude_dir / "history.jsonl"
    _rewrite_file(history)


def _worktree_copy_fallback(old_path, new_path):
    """Copy a worktree when move fails (locked directory on Windows).

    Uses robocopy to copy the tree, then updates git's internal
    worktree tracking to point to the new location.  Tries to close
    locking wezterm panes and remove the old directory.
    """
    info("Directory locked, falling back to copy...")
    win_old = wsl_to_win(old_path)
    win_new = wsl_to_win(new_path)

    # robocopy /E = copy subdirs including empty, exit codes 0-7 are success
    r = subprocess.run(
        ["robocopy.exe", win_old, win_new, "/E", "/NFL", "/NDL",
         "/NJH", "/NJS", "/NC", "/NS", "/NP"],
        capture_output=True, text=True,
    )
    if r.returncode >= 8:
        die(f"robocopy failed (exit {r.returncode}):\n{r.stdout}\n{r.stderr}")

    # Read the .git file to find the worktree tracking dir
    git_file = new_path / ".git"
    if not git_file.is_file():
        die(f"No .git file in copied worktree at {new_path}")
    gitdir_ref = git_file.read_text().strip()
    if not gitdir_ref.startswith("gitdir: "):
        die(f"Unexpected .git contents: {gitdir_ref}")
    tracking_dir = Path(gitdir_ref[len("gitdir: "):])
    gitdir_file = tracking_dir / "gitdir"

    if not gitdir_file.exists():
        die(f"Git tracking dir not found: {tracking_dir}")

    # Update the tracking dir's gitdir to point to the new location
    gitdir_file.write_text(str(new_path / ".git") + "\n")
    info(f"Updated git worktree tracking: {gitdir_file}")

    # Try to release the lock and remove old directory
    _try_remove_old_worktree(old_path)

    return new_path


def _queue_stale_dir(path):
    """Add a directory to the stale cleanup queue."""
    stale_file = CONFIG_DIR / "stale_dirs.json"
    stale = []
    if stale_file.exists():
        try:
            stale = json.loads(stale_file.read_text())
        except (json.JSONDecodeError, OSError):
            pass
    entry = str(path)
    if entry not in stale:
        stale.append(entry)
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        stale_file.write_text(json.dumps(stale, indent=2) + "\n")


def _try_remove_old_worktree(old_path):
    """Try to close locking panes and remove a stale worktree directory."""
    import time

    locks = find_directory_locks(old_path)
    if locks:
        closed, _skipped = close_wezterm_panes(locks)
        if closed:
            time.sleep(1)  # give Windows time to release handles

    # Try removal
    try:
        subprocess.run(
            ["cmd.exe", "/c", "rmdir", "/s", "/q", wsl_to_win(old_path)],
            capture_output=True, text=True, timeout=10,
        )
    except (subprocess.TimeoutExpired, OSError):
        pass

    if old_path.exists():
        _queue_stale_dir(old_path)
        warn(f"Old directory still locked, queued for cleanup: {old_path}")


def _cleanup_stale_dirs():
    """Remove previously locked directories that may now be unlocked."""
    stale_file = CONFIG_DIR / "stale_dirs.json"
    if not stale_file.exists():
        return
    try:
        stale = json.loads(stale_file.read_text())
    except (json.JSONDecodeError, OSError):
        return
    remaining = []
    for dir_path in stale:
        p = Path(dir_path)
        if not p.exists():
            continue
        try:
            subprocess.run(
                ["cmd.exe", "/c", "rmdir", "/s", "/q", wsl_to_win(p)],
                capture_output=True, text=True, timeout=10,
            )
        except (subprocess.TimeoutExpired, OSError):
            pass
        if p.exists():
            remaining.append(dir_path)
        else:
            info(f"Cleaned up stale directory: {dir_path}")
    if remaining:
        stale_file.write_text(json.dumps(remaining, indent=2) + "\n")
    else:
        stale_file.unlink(missing_ok=True)


def wsl_to_win(path):
    """Convert /c/foo to C:\\foo for Windows executables."""
    s = str(path)
    m = re.match(r'^/([a-zA-Z])/(.*)', s)
    if m:
        drive = m.group(1).upper()
        rest = m.group(2).replace("/", "\\")
        return f"{drive}:\\{rest}"
    return s


def detect_current_project():
    """Detect project tag from current working directory."""
    cwd = os.environ.get("GROVE_ORIG_CWD", str(Path.cwd())).lower()
    reg = Registry()
    for tag, p in reg.projects.items():
        project_path = str(Path(p["path"])).lower()
        if cwd == project_path or cwd.startswith(project_path + "/"):
            return tag
    return None


# ── Subcommands ──────────────────────────────────────────────────────────────

def cmd_config_init(args):
    """Initialize or show config."""
    if CONFIG_FILE.exists() and not args.force:
        print(f"Config already exists: {CONFIG_FILE}")
        print(json.dumps(json.loads(CONFIG_FILE.read_text()), indent=2))
        return
    cfg = Config()
    cfg.save()
    print(f"Created config: {CONFIG_FILE}")
    print(json.dumps(cfg.data, indent=2))


def cmd_new(args):
    """Create a new worktree project."""
    cfg = Config()
    reg = Registry()
    git = Git(cfg.main_repo)

    tag = validate_tag(args.tag)

    if reg.get(tag):
        die(f"Project '{tag}' already exists in registry")

    # Derive branch name
    if args.branch:
        branch = args.branch
    elif args.issue:
        branch = f"DESKTOP-{args.issue}-{tag}"
    else:
        branch = tag

    # Resolve base ref
    upstream = cfg.upstream_remote
    if args.base:
        base_ref = args.base
        # Add remote prefix if not already present
        if "/" not in base_ref:
            # Check for stable/ pattern
            if re.match(r'^\d+\.\d+', base_ref):
                base_ref = f"{upstream}/stable/{base_ref}"
            else:
                base_ref = f"{upstream}/{base_ref}"
    else:
        base_ref = f"{upstream}/{cfg.default_base}"

    worktree_path = Path(cfg.work_dir) / f"{cfg.dir_prefix}{tag}"

    if worktree_path.exists():
        die(f"Directory already exists: {worktree_path}")

    # Fetch and create
    git.fetch(upstream)
    info(f"Creating worktree: {branch} at {worktree_path} from {base_ref}")
    git.worktree_add(worktree_path, branch, base_ref)

    # Register
    issue = args.issue if hasattr(args, "issue") else None
    reg.add(tag, worktree_path, branch, base_ref, issue=issue)

    print()
    print(f"  {green('Created')} project {bold(tag)}")
    if issue:
        print(f"  Issue:   DESKTOP-{issue}")
    print(f"  Branch:  {branch}")
    print(f"  Base:    {base_ref}")
    print(f"  Path:    {worktree_path}")
    _set_wezterm_tab_title(tag)
    print(f"__POSTCD__{worktree_path}")


def cmd_fork(args):
    """Fork an existing project into a new worktree."""
    cfg = Config()
    reg = Registry()
    git = Git(cfg.main_repo)

    source_tag = args.source
    source = reg.get(source_tag)
    if not source:
        die(f"Unknown project '{source_tag}'. Use 'grove list' to see projects.")

    new_tag = validate_tag(args.tag)
    if reg.get(new_tag):
        die(f"Project '{new_tag}' already exists in registry")

    # Derive branch name
    if args.branch:
        branch = args.branch
    elif args.issue:
        branch = f"DESKTOP-{args.issue}-{new_tag}"
    else:
        branch = new_tag

    base_ref = source["branch"]
    worktree_path = Path(cfg.work_dir) / f"{cfg.dir_prefix}{new_tag}"

    if worktree_path.exists():
        die(f"Directory already exists: {worktree_path}")

    info(f"Creating worktree: {branch} at {worktree_path} from {base_ref}")
    git.worktree_add(worktree_path, branch, base_ref)

    issue = args.issue if hasattr(args, "issue") else None
    reg.add(new_tag, worktree_path, branch, base_ref, issue=issue)

    print()
    print(f"  {green('Created')} project {bold(new_tag)} (forked from {bold(source_tag)})")
    if issue:
        print(f"  Issue:   DESKTOP-{issue}")
    print(f"  Branch:  {branch}")
    print(f"  Base:    {base_ref}")
    print(f"  Path:    {worktree_path}")
    _set_wezterm_tab_title(new_tag)
    print(f"__POSTCD__{worktree_path}")


def cmd_done(args):
    """Remove a project worktree and clean up."""
    cfg = Config()
    reg = Registry()
    git = Git(cfg.main_repo)

    tag = args.tag
    project = reg.get(tag)
    if not project:
        die(f"Unknown project '{tag}'. Use 'grove list' to see projects.")

    wt_path = Path(project["path"])
    branch = project["branch"]

    # ── Safety checks ────────────────────────────────────────────────────
    problems = []

    if wt_path.exists():
        # Check for untracked files
        untracked = git.untracked_files(wt_path)
        if untracked:
            problems.append(("Untracked files", untracked))

        # Check for uncommitted changes (staged + unstaged)
        uncommitted = git.uncommitted_changes(wt_path)
        if uncommitted:
            problems.append(("Uncommitted changes", uncommitted))

        # Check if branch is pushed to fork remote
        unpushed = git.unpushed_commits(wt_path, branch, cfg.fork_remote)
        if unpushed == -1:
            problems.append(("Branch not pushed", [f"{branch} has no remote tracking branch on {cfg.fork_remote}"]))
        elif unpushed > 0:
            problems.append(("Unpushed commits", [f"{unpushed} commit(s) not pushed to {cfg.fork_remote}/{branch}"]))

    if problems and not args.force:
        print(f"\n{red('Cannot remove')} project {bold(tag)}:\n")
        for label, items in problems:
            print(f"  {yellow(label)}:")
            shown = items[:10]
            for item in shown:
                print(f"    - {item}")
            if len(items) > 10:
                print(f"    ... and {len(items) - 10} more")
            print()
        die("Resolve issues above or use --force to override.")

    # ── Confirmation ─────────────────────────────────────────────────────
    if not args.force:
        print(f"\nWill remove project {bold(tag)}:")
        print(f"  Path:   {wt_path}")
        print(f"  Branch: {branch}")
        if not args.keep_local:
            print(f"  Delete local branch: yes")
        if not args.keep_remote:
            print(f"  Delete remote branch: {cfg.fork_remote}/{branch}")
        resp = input("\nProceed? [y/N] ")
        if resp.lower() != "y":
            print("Cancelled.")
            return

    # ── Remove worktree ──────────────────────────────────────────────────
    wt_removed = False
    if wt_path.exists():
        # Move our CWD out of the worktree so Windows allows deletion
        try:
            if Path(os.getcwd()).resolve().is_relative_to(wt_path.resolve()):
                os.chdir(cfg.main_repo)
        except (OSError, ValueError):
            pass
        info(f"Removing worktree at {wt_path}...")
        result = git.worktree_remove(wt_path, force=args.force, check=False)
        if result is None:
            # Try closing other wezterm panes that lock the directory
            import time
            locks = find_directory_locks(wt_path)
            closed, skipped_self = close_wezterm_panes(locks)
            if closed:
                time.sleep(1)
                result = git.worktree_remove(wt_path, force=args.force, check=False)
            if result is None:
                if skipped_self or not locks:
                    # We're running inside the locking tab, or it's an
                    # opaque Windows handle.  Proceed with cleanup and
                    # defer directory removal.
                    warn(f"Directory locked by current session, deferring removal")
                    _queue_stale_dir(wt_path)
                    # Detach git worktree tracking so the dir is just dead files
                    git.run("worktree", "prune", check=False)
                else:
                    report_directory_locks(wt_path)
                    sys.exit(1)
            else:
                wt_removed = True
        else:
            wt_removed = True
    else:
        warn(f"Worktree path not found: {wt_path}")
        wt_removed = True

    # Delete local branch
    if not args.keep_local:
        info(f"Deleting local branch {branch}...")
        git.branch_delete(branch)

    # Delete remote branch
    if not args.keep_remote:
        info(f"Deleting remote branch {cfg.fork_remote}/{branch}...")
        if not git.push_delete(cfg.fork_remote, branch):
            warn(f"Could not delete remote branch (may already be gone)")

    # Remove from registry
    reg.remove(tag)

    print(f"\n  {green('Removed')} project {bold(tag)}")
    if not wt_removed:
        print(f"  {yellow('Note:')} directory will be cleaned up on next run")
    # Tell the shell wrapper to cd out of the deleted worktree
    print(f"__POSTCD__{cfg.main_repo}")


def cmd_list(args):
    """List projects."""
    cfg = Config()
    reg = Registry()

    # Handle --tags-only early
    if args.tags_only:
        for tag in sorted(reg.tags()):
            print(tag)
        return

    all_projects = reg.projects
    git = Git(cfg.main_repo)

    # Split active vs frozen
    active_projects = {t: p for t, p in all_projects.items() if not p.get("frozen")}
    frozen_projects = {t: p for t, p in all_projects.items() if p.get("frozen")}

    # Collect untracked worktrees if --all
    untracked = []
    if args.all:
        registered_paths = {p["path"] for p in all_projects.values()}
        for wt in git.worktree_list():
            path = wt.get("path", "")
            if path not in registered_paths and not wt.get("bare"):
                untracked.append(wt)

    if not all_projects and not untracked:
        print("No projects registered. Use 'grove new <tag>' to create one.")
        return

    if args.json_output:
        out = dict(all_projects)
        if untracked:
            out["_untracked"] = untracked
        print(json.dumps(out, indent=2))
        return

    if args.short:
        for tag in sorted(active_projects):
            p = active_projects[tag]
            issue_str = f"#{p['issue']}" if p.get('issue') else ""
            print(f"{tag:16s} {issue_str:8s} {p['branch']:28s} {p['path']}")
        if frozen_projects:
            print()
            for tag in sorted(frozen_projects):
                p = frozen_projects[tag]
                issue_str = f"#{p['issue']}" if p.get('issue') else ""
                print(f"\u2744 {tag:14s} {issue_str:8s} {p['branch']:28s} {p['path']}")
        return

    # Full table output - check if any project has an issue
    any_has_issue = any(p.get("issue") for p in all_projects.values())

    def _get_status(tag):
        p = all_projects[tag]
        wt_path = Path(p["path"])
        branch = p["branch"]
        issue = p.get("issue")
        if not wt_path.exists():
            status = red("missing")
        elif git.is_dirty(wt_path):
            status = yellow("dirty")
        else:
            ahead, behind = git.ahead_behind(wt_path, branch, cfg.upstream_remote)
            parts = []
            if ahead:
                parts.append(f"{ahead} ahead")
            if behind:
                parts.append(f"{behind} behind")
            status = green(", ".join(parts)) if parts else green("clean")
        return (tag, issue, branch, status, str(wt_path))

    active_rows = []
    frozen_rows = []
    with ThreadPoolExecutor(max_workers=8) as pool:
        futures = {pool.submit(_get_status, tag): tag for tag in sorted(all_projects)}
        for future in as_completed(futures):
            row = future.result()
            tag = row[0]
            if tag in frozen_projects:
                frozen_rows.append(row)
            else:
                active_rows.append(row)
    active_rows.sort(key=lambda r: r[0])
    frozen_rows.sort(key=lambda r: r[0])

    # Add untracked
    for wt in untracked:
        branch = wt.get("branch", "(detached)")
        path = wt["path"]
        issue = extract_issue_from_branch(branch)
        active_rows.append(("?", issue, branch, gray("untracked"), path))
        if issue:
            any_has_issue = True

    all_rows = active_rows + frozen_rows
    if not all_rows:
        return

    # Calculate column widths across all rows for alignment
    tag_w = max(len(r[0]) for r in all_rows)
    branch_w = max(len(r[2]) for r in all_rows)

    def _print_rows(rows):
        if any_has_issue:
            for tag, issue, branch, status, path in rows:
                issue_str = f"#{issue}" if issue else ""
                print(f"{tag:<{tag_w}}  {issue_str:>7}  {branch:<{branch_w}}  {status:12s}  {gray(path)}")
        else:
            for tag, issue, branch, status, path in rows:
                print(f"{tag:<{tag_w}}  {branch:<{branch_w}}  {status:12s}  {gray(path)}")

    # Print header
    if any_has_issue:
        hdr = f"{'TAG':<{tag_w}}  {'ISSUE':>7}  {'BRANCH':<{branch_w}}  {'STATUS':12s}  PATH"
    else:
        hdr = f"{'TAG':<{tag_w}}  {'BRANCH':<{branch_w}}  {'STATUS':12s}  PATH"
    print(gray(hdr))
    print(gray("-" * len(hdr)))

    _print_rows(active_rows)

    if frozen_rows:
        print()
        print(gray(f"\u2744 Frozen ({len(frozen_rows)})"))
        _print_rows(frozen_rows)


def _set_wezterm_tab_title(title):
    """Set the current wezterm tab's title (if running in wezterm)."""
    pane_id = os.environ.get("WEZTERM_PANE")
    if not pane_id:
        return
    try:
        subprocess.run(
            ["wezterm.exe", "cli", "set-tab-title", "--pane-id", pane_id, title],
            capture_output=True, text=True, timeout=5,
        )
    except (subprocess.TimeoutExpired, OSError):
        pass


def cmd_freeze(args):
    """Freeze a project (exclude from launch, listed separately)."""
    reg = Registry()
    tag = args.tag
    if not reg.get(tag):
        die(f"Unknown project: {tag}")
    if reg.is_frozen(tag):
        warn(f"Project '{tag}' is already frozen")
        return
    reg.set_frozen(tag, True)
    _set_wezterm_tab_title(f"\u2744 {tag}")
    print(f"  {bold(tag)} is now frozen")


def cmd_thaw(args):
    """Thaw (unfreeze) a project."""
    reg = Registry()
    tag = args.tag
    if not reg.get(tag):
        die(f"Unknown project: {tag}")
    if not reg.is_frozen(tag):
        warn(f"Project '{tag}' is not frozen")
        return
    reg.set_frozen(tag, False)
    _set_wezterm_tab_title(tag)
    print(f"  {bold(tag)} is now active")


def cmd_launch(args):
    """Launch terminal tabs for projects."""
    cfg = Config()
    reg = Registry()

    projects = reg.projects
    if not projects:
        die("No projects to launch. Use 'grove new' first.")

    # Filter by explicit tags (positional or --only)
    explicit_tags = args.tags or (
        [t.strip() for t in args.only.split(",")] if args.only else None
    )
    if explicit_tags:
        projects = {t: projects[t] for t in explicit_tags if t in projects}
        missing = [t for t in explicit_tags if t not in reg.projects]
        if missing:
            warn(f"Unknown tags: {', '.join(missing)}")
    elif not args.frozen:
        # Skip frozen projects unless explicitly requested
        skipped = [t for t in projects if projects[t].get("frozen")]
        projects = {t: p for t, p in projects.items() if not p.get("frozen")}
        if skipped:
            info(f"Skipping {len(skipped)} frozen project(s): {', '.join(sorted(skipped))}")

    if not projects:
        die("No matching projects to launch.")

    launch_cfg = cfg.launch
    terminal = launch_cfg.get("terminal", "wezterm")
    shell_cmd = launch_cfg.get("shell_command",
        "fish -l -c 'claude --dangerously-skip-permissions --continue; exec fish'")

    if args.wt:
        terminal = "wt"
    if args.no_claude:
        shell_cmd = "fish -l"

    # Find wezterm
    wez = None
    if terminal == "wezterm":
        for candidate in ["wezterm", "wezterm.exe", "/c/Program Files/WezTerm/wezterm.exe"]:
            if subprocess.run(["which", candidate], capture_output=True).returncode == 0 or Path(candidate).exists():
                wez = candidate
                break
        if not wez:
            die("wezterm not found. Install WezTerm or use --wt for Windows Terminal.")

    if args.dry_run:
        print(f"[{terminal} mode] Would launch {len(projects)} tab(s):\n")

    for tag in sorted(projects):
        p = projects[tag]
        wt_path = p["path"]
        win_path = wsl_to_win(wt_path)
        tab_title = f"\u2744 {tag}" if p.get("frozen") else tag

        if terminal == "wezterm":
            import shlex
            spawn_cmd = [wez, "cli", "spawn", "--cwd", win_path, "--",
                         "wsl.exe", "-e"] + shlex.split(shell_cmd)

            if args.dry_run:
                print(f"  {' '.join(spawn_cmd)}")
                print(f"  {wez} cli set-tab-title '{tab_title}'")
            else:
                try:
                    r = subprocess.run(spawn_cmd, capture_output=True, text=True, check=True)
                    pane_id = r.stdout.strip()
                    if pane_id:
                        title_cmd = [wez, "cli", "set-tab-title", "--pane-id", pane_id, tab_title]
                        subprocess.run(title_cmd, capture_output=True)
                except subprocess.CalledProcessError as e:
                    warn(f"Failed to launch tab for {tag}: {e}")

        elif terminal == "wt":
            # Windows Terminal via wt.exe
            wt_cmd = f"wt.exe -w 0 nt -p Ubuntu -d '{win_path}' --title '{tab_title}' wsl.exe -e {shell_cmd}"
            if args.dry_run:
                print(f"  {wt_cmd}")
            else:
                subprocess.run(wt_cmd, shell=True, check=False)

    if args.dry_run:
        print()


def cmd_adopt(args):
    """Import an existing worktree into the registry."""
    cfg = Config()
    reg = Registry()
    git = Git(cfg.main_repo)

    tag = validate_tag(args.tag)
    wt_path = Path(args.path).resolve()

    if reg.get(tag):
        die(f"Tag '{tag}' already exists in registry")

    if not wt_path.exists():
        die(f"Path does not exist: {wt_path}")

    # Detect branch from the worktree
    try:
        branch_out = subprocess.run(
            ["git", "-C", str(wt_path), "branch", "--show-current"],
            capture_output=True, text=True, check=True
        )
        branch = branch_out.stdout.strip()
    except subprocess.CalledProcessError:
        die(f"Could not detect branch at {wt_path}")

    if not branch:
        die(f"Worktree at {wt_path} is in detached HEAD state")

    # Determine base
    upstream = cfg.upstream_remote
    if args.base:
        base = args.base
        if "/" not in base:
            if re.match(r'^\d+\.\d+', base):
                base = f"{upstream}/stable/{base}"
            else:
                base = f"{upstream}/{base}"
    else:
        base = f"{upstream}/{cfg.default_base}"

    # Determine issue: explicit arg, or auto-detect from branch
    if hasattr(args, "issue") and args.issue:
        issue = args.issue
    else:
        issue = extract_issue_from_branch(branch)

    # Optionally move to standard naming
    final_path = wt_path
    if args.move:
        new_path = Path(cfg.work_dir) / f"{cfg.dir_prefix}{tag}"
        if new_path.exists():
            die(f"Target path already exists: {new_path}")
        info(f"Moving worktree: {wt_path} -> {new_path}")
        git.worktree_move(wt_path, new_path)
        final_path = new_path

    reg.add(tag, final_path, branch, base, issue=issue)

    print(f"\n  {green('Adopted')} project {bold(tag)}")
    if issue:
        print(f"  Issue:   DESKTOP-{issue}")
    print(f"  Branch:  {branch}")
    print(f"  Base:    {base}")
    print(f"  Path:    {final_path}")


def cmd_cd(args):
    """Change directory to a project's worktree."""
    reg = Registry()
    project = reg.get(args.tag)
    if not project:
        die(f"Unknown project '{args.tag}'. Use 'grove list' to see projects.")
    wt_path = Path(project["path"])
    if not wt_path.exists():
        die(f"Worktree path does not exist: {wt_path}")
    _set_wezterm_tab_title(args.tag)
    print(f"__POSTCD__{wt_path}")


def cmd_path(args):
    """Print the path for a project tag."""
    reg = Registry()
    project = reg.get(args.tag)
    if not project:
        print(f"Unknown project: {args.tag}", file=sys.stderr)
        sys.exit(1)
    print(project["path"])


def cmd_rename(args):
    """Rename a project tag (and optionally move directory)."""
    cfg = Config()
    reg = Registry()
    git = Git(cfg.main_repo)

    old_tag = args.old_tag
    new_tag = validate_tag(args.new_tag)

    project = reg.get(old_tag)
    if not project:
        die(f"Unknown project '{old_tag}'")

    same_tag = (old_tag == new_tag)
    if not same_tag and reg.get(new_tag):
        die(f"Tag '{new_tag}' already exists")

    old_path = Path(project["path"])
    new_path = old_path
    target_path = Path(cfg.work_dir) / f"{cfg.dir_prefix}{new_tag}"

    # Move directory if requested and not already at target
    if args.move and old_path != target_path:
        if target_path.exists():
            die(f"Target path already exists: {target_path}")
        if old_path.exists():
            info(f"Moving worktree: {old_path} -> {target_path}")
            # On Windows/WSL, move our CWD out so the directory isn't locked.
            # The shell wrapper handles cd'ing the interactive shell.
            try:
                if Path(os.getcwd()).resolve().is_relative_to(old_path.resolve()):
                    os.chdir(cfg.main_repo)
            except (OSError, ValueError):
                pass
            result = git.worktree_move(old_path, target_path, check=False)
            if result is None:  # run returns None on failure with check=False
                # Fallback: copy + repoint git tracking (Windows often locks dirs)
                new_path = _worktree_copy_fallback(old_path, target_path)
            else:
                new_path = target_path
        else:
            warn(f"Old path doesn't exist, just updating registry")
            new_path = target_path
    elif args.move and old_path == target_path:
        info(f"Already at target path: {old_path}")

    # Migrate Claude Code sessions if path changed
    if new_path != old_path:
        migrate_claude_sessions(old_path, new_path)

    # Update registry
    if same_tag:
        # Just update path
        reg._data["projects"][old_tag]["path"] = str(new_path)
        reg.save()
    else:
        # Copy data to new key, remove old
        reg._data["projects"][new_tag] = {
            **project,
            "path": str(new_path),
        }
        reg.remove(old_tag)

    if same_tag:
        print(f"\n  {green('Moved')} {bold(old_tag)}")
    else:
        print(f"\n  {green('Renamed')} {bold(old_tag)} -> {bold(new_tag)}")
    print(f"  Path:    {new_path}")
    # Tell the shell wrapper to cd to the new path
    if new_path != old_path:
        print(f"__POSTCD__{new_path}")


# ── CLI Setup ────────────────────────────────────────────────────────────────

def build_parser():
    parser = argparse.ArgumentParser(
        prog="grove",
        description="Git worktree manager for named projects",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""examples:
  grove new rawcodecs --issue 11301
  grove new ci-fix --branch fix-master-ci --base 25.3
  grove list
  grove cd rawcodecs
  grove launch --dry-run
  grove done rawcodecs
  grove adopt rawcodecs /c/WORK/desktop_master2
""",
    )
    sub = parser.add_subparsers(dest="command")

    # config
    p_cfg = sub.add_parser("config", help="Manage configuration")
    p_cfg.add_argument("--init", action="store_true", help="Create default config")
    p_cfg.add_argument("--force", action="store_true", help="Overwrite existing config")

    # new
    p_new = sub.add_parser("new", help="Create a new worktree project")
    p_new.add_argument("tag", help="Short project tag (e.g. rawcodecs, ci-fix)")
    p_new.add_argument("--issue", "-i", type=int, help="Issue number (creates DESKTOP-N branch)")
    p_new.add_argument("--branch", "-b", help="Explicit branch name")
    p_new.add_argument("--base", help="Base ref (e.g. master, 25.3)")

    # fork
    p_fork = sub.add_parser("fork", help="Fork an existing project into a new worktree")
    p_fork.add_argument("tags", nargs="+", metavar="TAG",
                        help="<new_tag> (detect source from cwd) or <source> <new_tag>")
    p_fork.add_argument("--issue", "-i", type=int, help="Issue number (creates DESKTOP-N branch)")
    p_fork.add_argument("--branch", "-b", help="Explicit branch name")

    # done
    p_done = sub.add_parser("done", help="Remove project worktree and clean up")
    p_done.add_argument("tag", nargs="?", help="Project tag to remove (default: detect from cwd)")
    p_done.add_argument("--force", "-f", action="store_true", help="Skip confirmation and dirty check")
    p_done.add_argument("--keep-local", action="store_true", help="Keep local branch")
    p_done.add_argument("--keep-remote", action="store_true", help="Keep remote branch")

    # list
    p_list = sub.add_parser("list", aliases=["ls"], help="List projects")
    p_list.add_argument("--all", "-a", action="store_true", help="Include untracked worktrees")
    p_list.add_argument("--check-remote", action="store_true", help="Verify remote branches exist")
    p_list.add_argument("--json", dest="json_output", action="store_true", help="JSON output")
    p_list.add_argument("--short", "-s", action="store_true", help="Compact output")
    p_list.add_argument("--tags-only", action="store_true", help="Just tag names (for completion)")

    # launch
    p_launch = sub.add_parser("launch", help="Open terminal tabs for projects")
    p_launch.add_argument("tags", nargs="*", help="Project tags to launch (default: all active)")
    p_launch.add_argument("--only", help="Comma-separated list of tags (deprecated, use positional)")
    p_launch.add_argument("--dry-run", action="store_true", help="Print commands only")
    p_launch.add_argument("--no-claude", action="store_true", help="Don't start Claude in tabs")
    p_launch.add_argument("--wt", action="store_true", help="Use Windows Terminal instead of WezTerm")
    p_launch.add_argument("--frozen", action="store_true", help="Include frozen projects")

    # adopt
    p_adopt = sub.add_parser("adopt", help="Import existing worktree into registry")
    p_adopt.add_argument("tag", help="Tag name for the project")
    p_adopt.add_argument("path", help="Path to existing worktree")
    p_adopt.add_argument("--base", help="Base ref")
    p_adopt.add_argument("--issue", "-i", type=int, help="Issue number")
    p_adopt.add_argument("--move", action="store_true", help="Move worktree to dt-<tag> naming")

    # cd
    p_cd = sub.add_parser("cd", help="Change directory to a project worktree")
    p_cd.add_argument("tag", nargs="?", help="Project tag (default: detect from cwd)")

    # path
    p_path = sub.add_parser("path", help="Print worktree path for a tag")
    p_path.add_argument("tag", nargs="?", help="Project tag (default: detect from cwd)")

    # rename
    p_rename = sub.add_parser("rename", aliases=["mv"], help="Rename a project tag")
    p_rename.add_argument("tags", nargs="+", metavar="TAG",
                          help="<new_tag> (detect old from cwd) or <old_tag> <new_tag>")
    p_rename.add_argument("--no-move", dest="move", action="store_false", default=True,
                          help="Don't move directory (just rename in registry)")

    # freeze / thaw
    p_freeze = sub.add_parser("freeze", help="Freeze a project (skip in launch, listed separately)")
    p_freeze.add_argument("tag", nargs="?", help="Project tag (default: detect from cwd)")
    p_thaw = sub.add_parser("thaw", aliases=["unfreeze"], help="Unfreeze a project")
    p_thaw.add_argument("tag", nargs="?", help="Project tag (default: detect from cwd)")

    return parser


def main():
    parser = build_parser()
    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    # Auto-detect tag from cwd when not provided
    if args.command in ("cd", "done", "path", "freeze", "thaw", "unfreeze") and not args.tag:
        detected = detect_current_project()
        if not detected:
            die(f"Not inside a registered project. Specify a tag or cd into one.")
        args.tag = detected
        info(f"Detected project: {detected}")

    if args.command in ("rename", "mv"):
        tags = args.tags
        if len(tags) == 1:
            detected = detect_current_project()
            if not detected:
                die(f"Not inside a registered project. Provide both old and new tag names.")
            args.old_tag = detected
            args.new_tag = tags[0]
            info(f"Detected project: {detected}")
        elif len(tags) == 2:
            args.old_tag = tags[0]
            args.new_tag = tags[1]
        else:
            die("rename expects 1 or 2 arguments: [old_tag] <new_tag>")

    if args.command == "fork":
        tags = args.tags
        if len(tags) == 1:
            detected = detect_current_project()
            if not detected:
                die(f"Not inside a registered project. Provide both source and new tag names.")
            args.source = detected
            args.tag = tags[0]
            info(f"Detected source project: {detected}")
        elif len(tags) == 2:
            args.source = tags[0]
            args.tag = tags[1]
        else:
            die("fork expects 1 or 2 arguments: [source] <new_tag>")

    dispatch = {
        "config": cmd_config_init,
        "new": cmd_new,
        "fork": cmd_fork,
        "done": cmd_done,
        "list": cmd_list,
        "ls": cmd_list,
        "launch": cmd_launch,
        "adopt": cmd_adopt,
        "cd": cmd_cd,
        "path": cmd_path,
        "rename": cmd_rename,
        "mv": cmd_rename,
        "freeze": cmd_freeze,
        "thaw": cmd_thaw,
        "unfreeze": cmd_thaw,
    }

    # Opportunistically clean up stale directories from prior locked renames
    _cleanup_stale_dirs()

    handler = dispatch.get(args.command)
    if handler:
        handler(args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
